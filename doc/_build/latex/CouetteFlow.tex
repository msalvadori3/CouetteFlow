%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional\else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{CouetteFlow: a solver for viscous flow between two plates}
\date{Mar 15, 2018}
\release{}
\author{Marc Salvadori}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


Author: Marc Salvadori

Email: \sphinxhref{mailto:msalvadori3@gatech.edu}{msalvadori3@gatech.edu}

Numerical solution schemes are often referred to as being explicit or implicit. When a direct computation of the dependent variables can be made in terms of known quantities, the computation is said to be explicit. When the dependent variables are defined by coupled sets of equations, and either a matrix or iterative technique is needed to obtain the solution, the numerical method is said to be implicit. In computational fluid dynamics, the governing equations are nonlinear, and the number of unknown variables is typically very large. Under these conditions implicitly formulated equations are almost always solved using iterative techniques.

Iterations are used to advance a solution through a sequence of steps from a starting state to a final, converged state. This is true whether the solution sought is either one step in a transient problem or a final steady-state result. In either case, the iteration steps resemble a time-like process. Of course, the iteration steps usually do not correspond to a realistic time-dependent behavior. In fact, it is this aspect of an implicit method that makes it attractive for steady-state computations, because the number of iterations required for a solution is often much smaller than the number of time steps needed for an accurate transient that asymptotically approaches steady conditions.

On the other hand, it is also this “distorted transient” feature that leads to the question, “What are the consequences of using an implicit versus an explicit solution method for a time-dependent problem?” The answer to this question has two parts. The first part has to do with numerical stability and the second part with numerical accuracy.

The purpose of this project is investigate the use of numerical schemes to try to answer the above questions.


\chapter{Contents}
\label{\detokenize{index:documentaion-for-solving-couetteflow-with-different-numerical-schemes}}\label{\detokenize{index:contents}}

\section{Project Description}
\label{\detokenize{background::doc}}\label{\detokenize{background:project-description}}

\subsection{Given task}
\label{\detokenize{background:given-task}}
In this exercise you calculate the viscous flow between two parallel paltes.

Such flow is described by the diffusion equation:
\begin{equation*}
\begin{split}\frac{\partial u}{\partial t} = \nu \frac{\partial^{2}u}{\partial y^{2}}\end{split}
\end{equation*}
Each plage is a distance L apart and the boundary conditions are \(u(y=0) = 0\) and \(u(y=L) = 1\). The exact solution for this equation for any location in space and time can be written as:
\begin{equation*}
\begin{split}u_{exact}(y,t) = \frac{y}{L} + \sum_{n=1}^{\infty } a_{n} sin\left ( n \pi \frac{y}{L} \right )exp\left [ -\nu \left ( \frac{n\pi}{L} \right )^{2} t \right ]\end{split}
\end{equation*}
where the constants, \(a_{n}\), in the infinite series depend on the initial condition specified. For this project you must solve the flow for the following initial condition:
\begin{equation*}
\begin{split}u(y)=\frac{y}{L} + sin\left ( \pi \frac{y}{L} \right )\end{split}
\end{equation*}
The following combined implicit-explicit difference formulation (Combined Method A in section 4.2.5 in Tannehill, Anderson and Pletcher) should be used:
\begin{equation*}
\begin{split}\frac{u^{n+1}_{j} - u^{n}_{j}}{\Delta t} = \frac{\nu}{\Delta y^{2}}\left [ \theta \left ( u^{n+1}_{j+1} - 2 u^{n+1}_{j} + u^{n+1}_{j-1} \right ) + (1-\theta)\left ( u^{n}_{j+1} - 2 u^{n}_{j} + u^{n}_{j-1} \right ) \right ]\end{split}
\end{equation*}
First, non-dimensionalize \(t\) and \(y\) by \(\tau\) and \(L\), respectively. Select an expression for \(\tau\) that essentially removes \(\nu\) from the governing flow equation. Write out the non-dimensional for this problem. You will numerically solve the non-dimensional form of the problem on a uniformly spaced mesh (i.e. constant \(\Delta y\)) with jmax grid points (including the bottom and top wall).

Compute the time-dependent and steady state solution using a direct solution technique (i.e. non-iterative) at each time step. To do this, first rearrange the discretized equation (non-dimensional form) so that it is in tri-diagonal form. You will be able to solve for all jmax points simultaneously at each time step by writing a computer program which uses the Thomas Algorithm.


\section{Setup}
\label{\detokenize{setup:setup-couetteflow}}\label{\detokenize{setup:setup}}\label{\detokenize{setup::doc}}

\subsection{Setting up Couette Solver}
\label{\detokenize{setup:setting-up-couette-solver}}\label{\detokenize{setup:id1}}

\subsection{Code Structure}
\label{\detokenize{setup:code-structure}}\label{\detokenize{setup:structure}}
The {\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}} code is divided into three major parts:
\begin{enumerate}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Input}: User input is entered into a file called \sphinxcode{input\_file.xml}.
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Main Program}: The main program for solving the elliptical grid is \sphinxcode{main.F90} in the \sphinxcode{\textless{}parent directory\textgreater{}/src/main} folder.
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Output}: Once the code is run, the results are stored in the \sphinxcode{\textless{}parent directory\textgreater{}/output/} folder.
\end{DUlineblock}

\end{enumerate}


\subsection{Input File}
\label{\detokenize{setup:input}}\label{\detokenize{setup:input-file}}
The inputs for CouetteFlow solver are specified in the \sphinxcode{input\_file.xml}. The input file is accessed as follows:
\begin{enumerate}
\item {} 
Go to the parent directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd \PYGZlt{}path to \textbar{}CoetteFlow\textbar{}\PYGZgt{}
\end{sphinxVerbatim}

Make sure that you are in the directory that contains the files \sphinxstyleliteralstrong{setup.py}, \sphinxstyleliteralstrong{input\_file.xml}, and the folder \sphinxstyleliteralstrong{src}.

\item {} 
Open the input file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} vi input\PYGZus{}file.xml
\end{sphinxVerbatim}

\item {} 
The main parts of the input file are shown below

\end{enumerate}

The input file is divided into different parts. The geometry is set in the \sphinxcode{\textless{}geometry\textgreater{}} module, which is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}geometry}\PYG{n+nt}{\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}jmax}\PYG{n+nt}{\PYGZgt{}}51\PYG{n+nt}{\PYGZlt{}/jmax\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/geometry\PYGZgt{}}
\end{sphinxVerbatim}

For setup of the solver, most of the inputs are set in the \sphinxcode{\textless{}setup\textgreater{}} module. A  snippet of this module is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}setup}\PYG{n+nt}{\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Project}\PYG{n+nt}{\PYGZgt{}}2D\PYGZus{}CouetteFlow\PYG{n+nt}{\PYGZlt{}/Project\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Utop}\PYG{n+nt}{\PYGZgt{}}1.0\PYG{n+nt}{\PYGZlt{}/Utop\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}nu}\PYG{n+nt}{\PYGZgt{}}1.0\PYG{n+nt}{\PYGZlt{}/nu\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}nmax}\PYG{n+nt}{\PYGZgt{}}1000000000\PYG{n+nt}{\PYGZlt{}/nmax\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}nout}\PYG{n+nt}{\PYGZgt{}}1\PYG{n+nt}{\PYGZlt{}/nout\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}L}\PYG{n+nt}{\PYGZgt{}}1.0\PYG{n+nt}{\PYGZlt{}/L\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}dt}\PYG{n+nt}{\PYGZgt{}}10000.0\PYG{n+nt}{\PYGZlt{}/dt\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}theta}\PYG{n+nt}{\PYGZgt{}}1.0\PYG{n+nt}{\PYGZlt{}/theta\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}RMSres}\PYG{n+nt}{\PYGZgt{}}1.0e\PYGZhy{}7\PYG{n+nt}{\PYGZlt{}/RMSres\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/setup\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Compilation}
\label{\detokenize{setup:compilation}}\label{\detokenize{setup:id2}}
The following sequence of commands is used to compile a single simulation.
\begin{enumerate}
\item {} 
Go to the parent directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd \PYGZlt{}path to \textbar{}CouetteFlow\textbar{}\PYGZgt{}
\end{sphinxVerbatim}

Make sure that you are in the directory that contains the files \sphinxstyleliteralstrong{setup.py}, \sphinxstyleliteralstrong{input\_file.xml}, and the folder \sphinxstyleliteralstrong{src}.

\item {} 
Clean existing results:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u clean heavy
\end{sphinxVerbatim}

This command removes the existing files in the output folder \sphinxcode{\textbar{}CouetteFlow\textbar{}/output/} and deletes the object files from previous compilations. \sphinxstylestrong{Backup any required results before using this command.}

\item {} 
Set working directory path:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u set\PYGZus{}path
\end{sphinxVerbatim}

This command sets the working directory path

\item {} 
Compile the build:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}e configure
\end{sphinxVerbatim}

An empty CMake window opens. Press \sphinxcode{{[}c{]}} on the keyboard to configure the program.
\begin{quote}
\begin{description}
\item[{This brings up the CMake window. There are two options for the \sphinxstyleliteralstrong{CMAKE\_BUILD\_TYPE} :}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{Release}: This compiles the program in regular mode; debugging flags are disabled.

\item {} 
\sphinxcode{Debug}:   This compiles the program in debug mode; errors and warnings are displayed on the terminal.

\end{itemize}

\end{description}

Press \sphinxcode{{[}Enter{]}} on the keyboard to edit the option (to change from \sphinxcode{Release} to \sphinxcode{Debug} or vice versa)

The file \sphinxstyleliteralstrong{\textbar{}CouetteFlow\textbar{}.x} will now be generated in the parent directory
\end{quote}

\item {} 
Execute the program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./couette.x
\end{sphinxVerbatim}

This command runs the program. If Debug mode is enabled in \sphinxstyleliteralstrong{COUETTE\_COMPILE\_DEFS}, appropriate output is printed on the Terminal screen.

\end{enumerate}


\subsection{Results}
\label{\detokenize{setup:results}}\label{\detokenize{setup:id3}}
The results are stored in the \sphinxcode{output/} folder inside the parent directory. The output directory contains several files \sphinxstylestrong{.dat} and \sphinxstylestrong{.tec} where the calculations are written. In addition, there is also a \sphinxcode{output/plot} folder, where figures from the calculated data are plotted. To plot the results. open the inputfile and enter the name of the \sphinxstylestrong{.dat} file that was generated in the \sphinxcode{files} entry (as shown below).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}PostProcessing}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}plot}\PYG{n+nt}{\PYGZgt{}}
       \PYG{n+nt}{\PYGZlt{}files}\PYG{n+nt}{\PYGZgt{}}RESULTDATFILE\PYG{n+nt}{\PYGZlt{}/files\PYGZgt{}}
       ...
    \PYG{n+nt}{\PYGZlt{}/plot\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/PostProcessing\PYGZgt{}}
\end{sphinxVerbatim}

Then, from the parent directory execute the following command to plot the results using {\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}}’s built-in plotting utility:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}p multi\PYGZus{}plot
\end{sphinxVerbatim}

This will generate the compined solution plots from the results, which will be stored in the \sphinxcode{output/plot} folder.


\section{Input File}
\label{\detokenize{inputfile::doc}}\label{\detokenize{inputfile:input-file}}\label{\detokenize{inputfile:inputfile}}
The input file is central location for setting any and all parameters for all the features in {\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}}. Depending on the type of operation being performed on {\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}}, the relevant input options are set in the input file.


\subsection{Structure of the Geometry Module}
\label{\detokenize{inputfile:str-geometry}}\label{\detokenize{inputfile:structure-of-the-geometry-module}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{geometry}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{jmax}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{51}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jmax}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{geometry}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Structure of Setup Module}
\label{\detokenize{inputfile:str-setup}}\label{\detokenize{inputfile:structure-of-setup-module}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{setup}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{Project}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{2}\PYG{n}{D\PYGZus{}CouetteFlow}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Project}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{Utop}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Utop}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{nu}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{nu}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{nmax}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1000000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{nmax}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{nout}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{nout}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{L}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{L}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{dt}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{10000.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{theta}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{theta}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{RMSres}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.0e\PYGZhy{}7}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{RMSres}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{setup}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Structure of Postprocessing Module}
\label{\detokenize{inputfile:str-post}}\label{\detokenize{inputfile:structure-of-postprocessing-module}}\phantomsection\label{\detokenize{inputfile:plot-input}}
{\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}} also allows the user to graphically visualize the results through the use of graphs and contours. Inputs to this plotting utility are also provided through the input file. The relevant block for this utility is shown below, and linked to the dedicated plotting utility page.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{PostProcessing}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{plot}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{iPost}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{iPost}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{Method}\PYG{o}{\PYGZgt{}}\PYG{n}{TecPlot}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Method}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{files}\PYG{o}{\PYGZgt{}}\PYG{n}{rmslog}\PYG{o}{.}\PYG{n}{dat}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{files}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{style}\PYG{o}{\PYGZgt{}}\PYG{n}{k} \PYG{o}{+}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{style}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{label}\PYG{o}{\PYGZgt{}}\PYG{n}{Grid}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{label}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{LegendFontSize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{16}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{LegendFontSize}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{FigureSize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{10} \PYG{l+m+mi}{7}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{FigureSize}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{AxisLabelSize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{21}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AxisLabelSize}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{AxisTitleSize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{22}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AxisTitleSize}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{XTickSize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{23}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{XTickSize}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{YTickSize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{24}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{YTickSize}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{plot}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{PostProcessing}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Code development}
\label{\detokenize{devel:code-development}}\label{\detokenize{devel::doc}}
The present project is aimed to develop a computer program for solving 1-D unsteady ‘Couette Flow’ problem. Hereafter, the program developed in this project is called ‘CouetteFlow’.


\subsection{CouetteFlow Code summary}
\label{\detokenize{devel:couetteflow-code-summary}}
The source code contains the following directories:
\begin{itemize}
\item {} 
io - input/output related routines

\item {} 
main - main program driver

\item {} 
math - thomas algorithm

\item {} 
modules - main couette flow solver routines

\item {} 
utils - list of useful FORTRAN utilities used within the program

\item {} 
couettepy - python wrapper for gridgen main program

\end{itemize}
\begin{quote}

Also a ‘CMakeLists.txt’ file is also included for cmake compiling.
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd CouetteFlow/src/
\PYGZdl{} ls
\PYGZdl{} CMakeLists.txt  io  main math modules utils couettepy
\end{sphinxVerbatim}

The \sphinxstylestrong{io} folder has \sphinxstylestrong{io.F90} file which contains \sphinxstylestrong{ReadInput(inputData)} subroutine. It also includes \sphinxstylestrong{input\_file\_xml} which describes the structure of the user run-time input file located in the main ‘src’ directory, and \sphinxstylestrong{output.F90} for storing data in bothb Tecplot and Python format.

The \sphinxstylestrong{main} folder is only used for containing the code driver file. The main routines is run by \sphinxstylestrong{couette.F90} which calls important subroutines from the rest of folders.


\subsection{Details of CouetteFlow development}
\label{\detokenize{devel:details-of-couetteflow-development}}
The source code shown below is \sphinxstylestrong{couette.F90} and it calls skeletal subroutines for generating grid structure. The main features of the main code is to (1) read input file, (2) make initialized variable arrays, (3) se the BCs and ICs, (4) set the time step for the solver, (5) Non-dimensionalize the variables , (6) use the thomas algorithm to calculate and update the velocity, and (7) finally write output files along with the RMS:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
PROGRAM main

      USE xml\PYGZus{}data\PYGZus{}input\PYGZus{}file
      USE CouetteSetup\PYGZus{}m,ONLY:Init,EndVars,TimeStep,NonDim2DimVars,\PYGZam{}
                              Dim2NonDimVars
      USE parameters\PYGZus{}m,ONLY:wp
      USE SimVars\PYGZus{}m,ONLY:fileLength,c1,c2,cr,elapse\PYGZus{}time,rate,iflag,\PYGZam{}
                          dt,t,nmax,rms\PYGZus{}SS,rms\PYGZus{}US,maxRMS\PYGZus{}US
      USE CouetteSolver\PYGZus{}m,ONLY:TriDiag,SteadySoln,UnsteadySoln,SteadyRMS,UnsteadyRMS
      USE output\PYGZus{}m,ONLY:WritePlotFile,WriteRMS

      IMPLICIT NONE

      TYPE(input\PYGZus{}type\PYGZus{}t) :: inputData
      CHARACTER(LEN=fileLength) ::output= \PYGZsq{}data\PYGZsq{}
      CHARACTER(LEN=fileLength) :: rmsout = \PYGZsq{}rms\PYGZsq{}
      INTEGER :: n

      ! Start the time measurements
      elapse\PYGZus{}time = 0.0\PYGZus{}wp

      CALL system\PYGZus{}clock(count\PYGZus{}rate=cr)
      rate = REAL(cr)
      CALL system\PYGZus{}clock(c1)

      ! Call the initialization of variables
      CALL Init(inputData)
      ! Setup the time step based

      IF (dt == 0.0\PYGZus{}wp) THEN
              iflag = 0
              WRITE(*,*)\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{}
              CALL TimeStep(iflag)
              WRITE(*,*)\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{}
              IF (iflag == 1) STOP

      END IF

      CALL SteadySoln()
      CALL NonDim2DimVars()
      CALL UnsteadySoln()
      CALL NonDim2DimVars()

      ! Output Initial Solutions
      WRITE(*,*) \PYGZsq{}Printing Initial Solution.......................................\PYGZsq{}
      CALL WritePlotFile(output,\PYGZsq{}\PYGZdq{}y\PYGZdq{},\PYGZdq{}u\PYGZdq{},\PYGZdq{}uExact\PYGZdq{},\PYGZdq{}yp\PYGZdq{},\PYGZdq{}up\PYGZdq{},\PYGZdq{}upExact\PYGZdq{}\PYGZsq{},inputData,t)
      WRITE(*,*)\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{}

      ! Time loop
      DO n = 1,nmax

        t = t+dt

        CALL Dim2NonDimVars()
        CALL TriDiag()
        CALL UnsteadySoln()
        CALL NonDim2DimVars()
        CALL UnsteadyRMS()
        CALL SteadyRMS()
        MaxRMS\PYGZus{}US = MAX(MaxRMS\PYGZus{}US,rms\PYGZus{}US)
        CALL WriteRMS(n,rms\PYGZus{}SS,rms\PYGZus{}US,rmsout,inputData)

        IF (MOD(n,inputData\PYGZpc{}setup\PYGZpc{}nout) == 0) THEN
            CALL WritePlotFile(output,\PYGZsq{}\PYGZdq{}y\PYGZdq{},\PYGZdq{}u\PYGZdq{},\PYGZdq{}uExact\PYGZdq{},\PYGZdq{}yp\PYGZdq{},\PYGZdq{}up\PYGZdq{},\PYGZdq{}upExact\PYGZdq{}\PYGZsq{},inputData,t)
        END IF

        IF (rms\PYGZus{}SS \PYGZlt{} inputData\PYGZpc{}setup\PYGZpc{}RMSres) THEN
                iflag = 1
                WRITE(*,*) \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{}
                WRITE(*,*) \PYGZsq{}Convergence Successful=======\PYGZgt{} Printing Solution.....................\PYGZsq{}
                CALL WritePlotFile(output,\PYGZsq{}\PYGZdq{}y\PYGZdq{},\PYGZdq{}u\PYGZdq{},\PYGZdq{}uExact\PYGZdq{},\PYGZdq{}yp\PYGZdq{},\PYGZdq{}up\PYGZdq{},\PYGZdq{}upExact\PYGZdq{}\PYGZsq{},inputData,t)
                WRITE(*,*) \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{}
                EXIT
        ENDIF

       END DO

       ! Last check for non\PYGZhy{}convergence

       IF (iflag /= 1) THEN
               WRITE(*,\PYGZsq{}(A,X,I6.6,X,A)\PYGZsq{}) \PYGZsq{}CONVERGENCE FAILURE WITH\PYGZsq{},nmax,\PYGZsq{}ITERATIONS\PYGZsq{}
       END IF

      CALL system\PYGZus{}clock(c2)

      elapse\PYGZus{}time = REAL(c2\PYGZhy{}c1,KIND=wp)/rate

      WRITE(*,*) \PYGZdq{}\PYGZdq{}
      WRITE(*,\PYGZsq{}(A,F10.6,A)\PYGZsq{}) \PYGZdq{}\textbar{} Total elapse time: \PYGZdq{},elapse\PYGZus{}time, \PYGZdq{} [s]\textbar{}\PYGZdq{}

END PROGRAM main
\end{sphinxVerbatim}


\section{CouetttePy}
\label{\detokenize{couettepy:couetttepy}}\label{\detokenize{couettepy::doc}}
CouettePy is a python-based library of {\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}} that is developed to assist the user with i/o procedures, utilities and code options/testing. In the following, the commands are listed by category and discussion is provided in each respective section.


\subsection{Compilation Options}
\label{\detokenize{couettepyfiles/compile::doc}}\label{\detokenize{couettepyfiles/compile:compilation-options}}
{\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}} has several builtin compilation options, that can be accessed through the command \sphinxstyleliteralstrong{./setup.py -e} and allied utilities that can be accessed using \sphinxstyleliteralstrong{./setup.py -u}. These are described here.


\subsubsection{Configure}
\label{\detokenize{couettepyfiles/compile:configure}}
The default method for compiling {\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}} from scratch is using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}e configure couetteflow
\end{sphinxVerbatim}

This generates a CCMake window with configuration options that can be chosen by the user. Refer to the {\hyperref[\detokenize{setup:compilation}]{\sphinxcrossref{\DUrole{std,std-ref}{compilation section}}}} of the {\hyperref[\detokenize{setup:setup-couetteflow}]{\sphinxcrossref{\DUrole{std,std-ref}{\textbar{}CouetteFlow\textbar{} Setup page}}}} for details on using this method.


\subsubsection{Compile}
\label{\detokenize{couettepyfiles/compile:compile}}
This option should be used only if {\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}} has been configured first (using \sphinxcode{-e configure}). This recompiles the code with any changes, while retaining the build directory and related objects. It can be executed using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}e compile couetteflow
\end{sphinxVerbatim}


\subsection{Setting the path}
\label{\detokenize{couettepyfiles/compile:setting-the-path}}
{\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}} requires the path to the working directory be set every time a run is executed from scratch (i.e. after clearing all the compilations). The {\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}} executable \sphinxcode{couette.x} will not run without this path set. To set the path, compile/configure {\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}} using any of the options, and then run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u set\PYGZus{}path
\end{sphinxVerbatim}


\subsection{Cleaning commands}
\label{\detokenize{couettepyfiles/compile:cleaning-commands}}
After completion of a simulation, or before running a fresh simulation, {\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}} can be cleared of compiled objects, results and other files. There are three variants to clean {\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}}. The first is to perform a complete clean, which removes the build directories, the executables and any generated results. This can be accomplished by running:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u clean heavy
\end{sphinxVerbatim}

On the other hand, the build directories and executables can be retained while deleting only the results by running the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u clean results
\end{sphinxVerbatim}

The last variant is where the build directories alone are cleared, retaining the results and the executables, which is done using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u clean
\end{sphinxVerbatim}


\subsection{Plotting Utility}
\label{\detokenize{couettepyfiles/plot:plot}}\label{\detokenize{couettepyfiles/plot::doc}}\label{\detokenize{couettepyfiles/plot:plotting-utility}}
{\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}} has a builtin plotting utility that allows for plotting of the generated data without the use of external tools. Similar to all the other features, the plotting utility is also accessed through the input file, which is accessed as follows.
\begin{enumerate}
\item {} 
Go to the parent directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd \PYGZlt{}path to \textbar{}CouetteFlow\textbar{}\PYGZgt{}
\end{sphinxVerbatim}

Make sure that you are in the directory that contains the files \sphinxstyleliteralstrong{setup.py}, \sphinxstyleliteralstrong{input\_file.xml}, and the folder \sphinxstyleliteralstrong{src}.

\item {} 
Open the input file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} vi input\PYGZus{}file.xml
\end{sphinxVerbatim}

\end{enumerate}

The section of the inputfile devoted to post-processing is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}PostProcessing}\PYG{n+nt}{\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}plot}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}iPost}\PYG{n+nt}{\PYGZgt{}}1\PYG{n+nt}{\PYGZlt{}/iPost\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Method}\PYG{n+nt}{\PYGZgt{}}TecPlot\PYG{n+nt}{\PYGZlt{}/Method\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}files}\PYG{n+nt}{\PYGZgt{}}file1.dat\PYG{n+nt}{\PYGZlt{}/files\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}style}\PYG{n+nt}{\PYGZgt{}}k +r \PYGZhy{}c :g \PYGZhy{}.y \PYGZhy{}\PYGZhy{}m\PYG{n+nt}{\PYGZlt{}/style\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}label}\PYG{n+nt}{\PYGZgt{}}Var1\PYG{n+nt}{\PYGZlt{}/label\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}LegendFontSize}\PYG{n+nt}{\PYGZgt{}}16\PYG{n+nt}{\PYGZlt{}/LegendFontSize\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}FigureSize}\PYG{n+nt}{\PYGZgt{}}10 7\PYG{n+nt}{\PYGZlt{}/FigureSize\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}AxisLabelSize}\PYG{n+nt}{\PYGZgt{}}21\PYG{n+nt}{\PYGZlt{}/AxisLabelSize\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}AxisTitleSize}\PYG{n+nt}{\PYGZgt{}}22\PYG{n+nt}{\PYGZlt{}/AxisTitleSize\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}XTickSize}\PYG{n+nt}{\PYGZgt{}}23\PYG{n+nt}{\PYGZlt{}/XTickSize\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}YTickSize}\PYG{n+nt}{\PYGZgt{}}24\PYG{n+nt}{\PYGZlt{}/YTickSize\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}/plot\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/PostProcessing\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{Options in the plotting module}
\label{\detokenize{couettepyfiles/plot:options-in-the-plotting-module}}\begin{enumerate}
\item {} 
The data files generated from a {\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}} run (or any external data file) is placed in the \sphinxstyleliteralstrong{output} folder. The name of the file should not have any spaces or special characters (like colon :, quotation marks “” or ”, brackets or parenthesis () {[}{]} etc). The file name is entered into the \sphinxcode{\textless{}files\textgreater{}} field in the input file. If there are more than 1 file, they are entered one after another.

\item {} 
The \sphinxcode{\textless{}style\textgreater{}} entry refers to the line style and color used. There are seven available colors in Python by default: RGBCMYK (Red, Green, Blue, Cyan, Magenta, Yellow and Black). Markers can be placed on the lines using the marker symbols (eg. \sphinxcode{+r} generates a red line with + shaped markers). Line styles can also be changed using appropriate symbols (eg. \sphinxcode{-{-}m} generates a dashed magenta line, while \sphinxcode{-.y} generates a dot-dashed yellow line).

\item {} 
The \sphinxcode{\textless{}label\textgreater{}} entry is to populate the legend. If there are N files for N different variables, then the legend is populated according to the entries in this field.

\item {} 
The remaining entries are to adjust the figure parameters, like font size and figure size.

\end{enumerate}


\subsubsection{Using the plotting module}
\label{\detokenize{couettepyfiles/plot:using-the-plotting-module}}\begin{enumerate}
\item {} 
Enter the names of the data files in the input file

\item {} 
Set the required number of legend entries and line styles, depending on  how many files/variables are being plotted.

\item {} 
Adjust any other plot parameters as required.

\item {} 
The plotting module also provides a generalized feature to make plots from input data. This feature is also accessed through the \sphinxcode{input\_file.xml}. The input data (.dat) files are entered in the \sphinxcode{files} section of the input file. The plotting utility is then accessed using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}p single\PYGZus{}plot options \PYGZdq{}\PYGZob{}\PYGZlt{}plot options\PYGZgt{}\PYGZcb{}\PYGZdq{}
\end{sphinxVerbatim}

\end{enumerate}
\begin{quote}

An example of this input for the plotting utility is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}p single\PYGZus{}plot options \PYGZdq{}\PYGZob{}\PYGZsq{}title\PYGZsq{}:[\PYGZsq{}RMS Residual for Grid\PYGZsh{}5\PYGZsq{}],
  \PYGZsq{}xlabel\PYGZsq{}:[\PYGZsq{}Number of Iterations\PYGZsq{}],\PYGZsq{}ylabel\PYGZsq{}:[\PYGZsq{}RMS\PYGZsq{}],
  \PYGZsq{}grid\PYGZsq{}:[\PYGZsq{}on\PYGZsq{}],\PYGZsq{}legend\PYGZsq{}:[\PYGZsq{}False\PYGZsq{}],\PYGZsq{}legend\PYGZus{}frame\PYGZsq{}:[\PYGZsq{}True\PYGZsq{}],
  \PYGZsq{}legend\PYGZus{}loc\PYGZsq{}:[\PYGZsq{}lower right\PYGZsq{}]\PYGZcb{}\PYGZdq{}
\end{sphinxVerbatim}
\begin{description}
\item[{The options give flexibility to set the graph title, the labels for the axes, select the columns of data from the input .dat file that we want to plot, set the legend properties, etc.}] \leavevmode
Note that if no options are provided as in the example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}p single\PYGZus{}plot options
\end{sphinxVerbatim}

default options wil be used for the picture name and axes/title labels.
Note that the file and picture options must be provided in the input file,
in the \sphinxcode{\textless{}PostProcessing\textgreater{}} section.

\end{description}
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
The above command is meant to be used with a generic .dat file, without header, where data is distributed column-wise.
\end{sphinxadmonition}


\subsection{Documentation}
\label{\detokenize{couettepyfiles/documentation:documentation}}\label{\detokenize{couettepyfiles/documentation::doc}}\label{\detokenize{couettepyfiles/documentation:id1}}
The {\color{red}\bfseries{}\textbar{}CouetteFlow\textbar{}} documentation is written using restructured text (reST) Sphinx, and can be manipulated using python routines in couettepy.


\subsubsection{Building}
\label{\detokenize{couettepyfiles/documentation:building}}
The documentation can be built using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u doc build
\end{sphinxVerbatim}

This runs Sphinx in the documentation directory, and creates the html files using a make command. The command runs Sphinx twice to make sure references are interlinked properly.


\subsubsection{Viewing}
\label{\detokenize{couettepyfiles/documentation:viewing}}
This command is used for viewing the documentation. It is only available after running the build command above, so that the documentation is created. The documentation can be opened using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u doc open
\end{sphinxVerbatim}

The documentation requires a compatible version of a web broswer (preferably Google Chrome or Mozilla Firefox). If a compatible browser is installed, the documentation will open when the above command is executed. Otherwise, an error message will be displayed. In case an error message is displayed, the documentation can manually be opened on a web browser from the directory \sphinxstylestrong{\textless{}GridGen parent directory\textgreater{}/doc/\_build/html/index.html}


\subsubsection{Cleaning}
\label{\detokenize{couettepyfiles/documentation:cleaning}}
The built documentation can be cleaned (i.e. all the compiled files can be deleted while retaining the source content) using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u doc clean
\end{sphinxVerbatim}


\subsubsection{Closing Notes}
\label{\detokenize{couettepyfiles/documentation:closing-notes}}\begin{enumerate}
\item {} 
As with any browser-based content, the appearance of the content is dependent on the capability of the browser to render the elements on the webpage. Depending on the bworser present on the machine, the content may appear different.

\end{enumerate}


\section{Evaluation Cases}
\label{\detokenize{results:evaluation-cases}}\label{\detokenize{results::doc}}\label{\detokenize{results:testcases-main}}

\subsection{Couette Flow Results}
\label{\detokenize{results:couette-flow-results}}\label{\detokenize{results:test-cases}}

\subsubsection{Results summary}
\label{\detokenize{cases/results:results-summary}}\label{\detokenize{cases/results::doc}}
\begin{sphinxadmonition}{note}{Note:}
Some of the contents in this page are animations of the solution. In order to view please visit \sphinxhref{http://elliptical-grid-generator.readthedocs.io/en/latest/}{ReadDocs}
\end{sphinxadmonition}


\paragraph{A) Show the expression for \protect\(\tau\protect\) that non-dimensionalizes the governing PDE. Show the non-dimensionalized form of the governing PDE.}
\label{\detokenize{cases/results:a-show-the-expression-for-that-non-dimensionalizes-the-governing-pde-show-the-non-dimensionalized-form-of-the-governing-pde}}\begin{itemize}
\item {} 
Non-dimensionalized variables:
\begin{equation*}
\begin{split}u' = \frac{u}{u_{top}}\end{split}
\end{equation*}\begin{equation*}
\begin{split}t' = \frac{t}{\tau}\end{split}
\end{equation*}\begin{equation*}
\begin{split}y' = \frac{y}{L}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\tau = \frac{L^{2}}{\nu}\end{split}
\end{equation*}
\item {} 
Non-dimensionalized governing PDE:
\begin{equation*}
\begin{split}\frac{\partial u'}{\partial t'} = \frac{\partial^{2}u'}{\partial y'^{2}}\end{split}
\end{equation*}
\end{itemize}


\paragraph{B) Show the non-dimensionalized form of the time-dependent exact solution expression for the specified boundary and initial conditions given in this problem.}
\label{\detokenize{cases/results:b-show-the-non-dimensionalized-form-of-the-time-dependent-exact-solution-expression-for-the-specified-boundary-and-initial-conditions-given-in-this-problem}}
To find the time-dependent exact solution, we need to first find \(a_{n}\) which satisfies the given initial velocity profile. The resolved form of \(a_{n}\) is then re-written as:
\begin{equation*}
\begin{split}a_{n} = \left\{\begin{matrix} 1 \text{  if } n = 1 \\ 0 \text{  if } n \neq  1 \end{matrix}\right.\end{split}
\end{equation*}
Thus, applying the resolved \(a_{n}\) into the given exact solution results in:
\begin{equation*}
\begin{split}u'_{exact}(t',y') = y' + \text{sin}(\pi y') \text{exp}[-\pi^{2}t']\end{split}
\end{equation*}

\paragraph{C) Provide a brief description of the finite difference scheme (in non-dimensional form), the solution method used and exactly how the boundary and initial conditions are applied.}
\label{\detokenize{cases/results:c-provide-a-brief-description-of-the-finite-difference-scheme-in-non-dimensional-form-the-solution-method-used-and-exactly-how-the-boundary-and-initial-conditions-are-applied}}
Given finite difference scheme has a weighting parameter \(\theta\) to put an effect of implicit solution. If \(\theta\) is equal to 1, the scheme becomes to fully implicit, otherwise, the scheme can be partially implicit or explicit (\(\theta\) = 0). Rearranging the given finite difference equation leads to the following simplified form:
\begin{equation*}
\begin{split}a_{j} u^{n+1}_{j+1} + b_{j} u^{n+1}_{j} + c_{j} u^{n+1}_{j-1} = d_{j}\end{split}
\end{equation*}
where
\begin{align*}\!\begin{aligned}
a_{j} = -r \theta\\
b_{j} = 1 + 2r\theta\\
c_{j} = -r\theta\\
d_{j} = u^{n}_{j} + r(1-\theta)\left \{ u^{n}_{j-1} - 2u^{n}_{j} + u^{n}_{j+1} \right \}\\
\end{aligned}\end{align*}
Here, the resulting equation has simplified coefficient \(r = \frac{\Delta t'}{\Delta y'^{2}}\).

For the boundary condition, non-slip condition is applied to both upper and bottom plates. Thus, \(y(0) = 0\) and \(y(L)=1\) remain unchanged while the inner point quantities varies during the transient phase. The initial condition described earlier can satisfy the given boundary condition here. The Thomas algorithm is set to unchange the boundary condition as the time varies.


\paragraph{D) Show the expression used for calculating the RMS Error relative to the time-dependent exact solution. Also show the expression used for calculating the RMS Error relative to the steady-state exact solution. Also, give a statement of the criteria used to end the calculations.}
\label{\detokenize{cases/results:d-show-the-expression-used-for-calculating-the-rms-error-relative-to-the-time-dependent-exact-solution-also-show-the-expression-used-for-calculating-the-rms-error-relative-to-the-steady-state-exact-solution-also-give-a-statement-of-the-criteria-used-to-end-the-calculations}}
In this project, two different types of RMS error formulation are used:
\begin{itemize}
\item {} 
RMS error relative to the exact time-dependent solution
\begin{equation*}
\begin{split}\text{RMS}_{\text{NSS}}(t) = \sqrt{\frac{1}{N} \sum_{\text{j}=2}^{\text{jmax}-1} \left [ \left ( u'_{exact,j}(t) - u'^{n} \right )^{2}  \right ]}\end{split}
\end{equation*}
where N is number of inner grid points.

\item {} 
RMS error relative to the exact steady-state solution:
\begin{equation*}
\begin{split}\text{RMS}_{\text{SS}}(t) = \sqrt{\frac{1}{N} \sum_{\text{j}=2}^{\text{jmax}-1} \left [ \left ( u'_{exact,j}(t=\infty ) - u'^{n} \right )^{2}  \right ]}\end{split}
\end{equation*}
\item {} 
The convergence criteria is limited by the following relation:
\begin{equation*}
\begin{split}\text{RMS}_{\text{SS}}(t) \leqslant 1\times 10^{-7}\end{split}
\end{equation*}
\end{itemize}


\paragraph{F) For \protect\(\theta = 0\protect\), present a graph which clearly shows the progression of velocity profiles during the flow development when \protect\(\text{jmax} = 51\protect\). The plot should show the initial profile, final steady state profile and at least 3 other non-steady-state profiles (i.e. all on the same plot). Overlay the exact numerical velocity profiles on this plot for the same points in time. Create similar plots for \protect\(\theta = 1/2\protect\) and \protect\(\theta = 1\protect\).}
\label{\detokenize{cases/results:f-for-present-a-graph-which-clearly-shows-the-progression-of-velocity-profiles-during-the-flow-development-when-the-plot-should-show-the-initial-profile-final-steady-state-profile-and-at-least-3-other-non-steady-state-profiles-i-e-all-on-the-same-plot-overlay-the-exact-numerical-velocity-profiles-on-this-plot-for-the-same-points-in-time-create-similar-plots-for-and}}
In this problem, the time step was employed as \(\Delta t'\) = 0.0002 in order to have stable convergence for every \(\theta\) cases. This time step was then applied to the other \(\theta\) cases. As the following three figures show, the numerical solution well follows the analytical solution in both time and spatial domain.
\begin{quote}
\begin{enumerate}
\item {} 
\(\theta\) = 0 (Fully explicit scheme): Converged at iteration number of 7990.

\end{enumerate}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{VelProfileA}.png}
\end{figure}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{VelProfileA}.gif}
\end{figure}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\(\theta\) = 0.5 (Crank-Nicolson scheme): Converged at iteration number of 7998.

\end{enumerate}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{VelProfileB}.png}
\end{figure}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{VelProfileB}.gif}
\end{figure}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
\(\theta\) = 1 (Fully implicit scheme): Converged at iteration number of 8006.

\end{enumerate}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{VelProfileC}.png}
\end{figure}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{VelProfileC}.gif}
\end{figure}
\end{quote}


\paragraph{G) Provides a comparison of the stability behavior of your solver to the stability analysis performed in Homework Assignment \#3. Compute \protect\(\text{jmax} = 51\protect\) cases with \protect\(\theta = 0\protect\), \protect\(1/2\protect\), and \protect\(1\protect\) using various values of \protect\(\Delta t\protect\) to explore the stability boundaries of your solver. Show and discuss whether or not your solver follows the theoretical stability behavior of these three numerical schemes.}
\label{\detokenize{cases/results:g-provides-a-comparison-of-the-stability-behavior-of-your-solver-to-the-stability-analysis-performed-in-homework-assignment-3-compute-cases-with-and-using-various-values-of-to-explore-the-stability-boundaries-of-your-solver-show-and-discuss-whether-or-not-your-solver-follows-the-theoretical-stability-behavior-of-these-three-numerical-schemes}}
\sphinxstylestrong{A.} The stability analysis can be summarized by:
\begin{itemize}
\item {} 
Unconditionally stable if \(\theta \geqslant \frac{1}{2}\)

\item {} 
Conditionally stable if \(0 \leqslant \theta < \frac{1}{2}\)

\end{itemize}

In the case of conditionally stable scheme, the maximum time step can be determined by using below relation so that the scheme is stable with given \(\theta\).
\begin{equation*}
\begin{split}\Delta t \leqslant \frac{\Delta y^{2}}{4\left ( \frac{1}{2}-\theta \right )}\end{split}
\end{equation*}

\subparagraph{1) \protect\(\theta\protect\) = 0 (Fully explicit)}
\label{\detokenize{cases/results:fully-explicit}}
According to the above relation, for \(\theta = 0\), the maximum time step should be 0.0002 to make the scheme stable. Following figures show the convergence history for three different time step cases: (1) ensurely stable time step, (2). maximum time step and (3). slightly bigger time-step than the maximum value. If you can’t see the movies below, you are seeing the printed version of document.

The figure below is the case with \(dt'\) = 0.0001 that is ensured for the stability for fully explicit scheme.
\begin{itemize}
\item {} 
\(dt' = 0.0001\)
\begin{itemize}
\item {} 
Movie of velcoity profile (online available)

\end{itemize}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{VelProfile_Theta0_dt_0001}.gif}
\end{figure}
\begin{itemize}
\item {} 
RMS error

\end{itemize}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{RMSlogdt0001}.png}
\end{figure}

\end{itemize}

Even the slightly bigger time-step causes the unstable solution and thus, the RMS error is taken off and goes to infinity after a certain number of iteration.
\begin{itemize}
\item {} 
\(dt' = 0.00021\)
\begin{itemize}
\item {} 
Movie of velocity profile (online available)

\end{itemize}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{VelProfile_Theta0_dt_00021}.gif}
\end{figure}
\begin{itemize}
\item {} 
RMS error

\end{itemize}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{RMSlogdt00021}.png}
\end{figure}

\end{itemize}


\subparagraph{2) \protect\(\theta\protect\) = 1/2 (Crank-Nicolson scheme)}
\label{\detokenize{cases/results:crank-nicolson-scheme}}\begin{itemize}
\item {} 
\sphinxstylestrong{Convergence check with the various time step:}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Non-dimensional time step \(\Delta t'\)
&
Maximum iteration for convergence
\\
\hline
0.0001
&
15996
\\
\hline
0.001
&
1600
\\
\hline
0.01
&
160
\\
\hline
0.1
&
15
\\
\hline
1.0
&
39
\\
\hline
10.0
&
390
\\
\hline
100.0
&
3893
\\
\hline
1000.0
&
38927
\\
\hline
10000.0
&
389268
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

All the cases above seem to be stable but the convergence is strongly sensitive to how big or small time step is. The interesting pattern to be observed here is that the maximum iteration number for convergence shows quadratic behavior. That is, quite small and quite big time step require long iterations. In particular, big time steps, 1000, 10000, and 100000 for examples, take long period to make the scheme converged into the specified RMS residual. This is somewhat unphysical. If 10,000 sec is taken as a time step, it will take about 123 years for the flow to be settled down to the steady-state.

The stability check can be done by looking at the movies as a function of different time-step. If you can’t see the movies below, you are seeing the printed version of document.
\begin{itemize}
\item {} 
\(dt' = 0.0001\)

\end{itemize}

The movies shown below is to show the velocity profile calculated by the present numerical solution and analytic solution. In this case, sufficiently small time-steps can ensure the physically proper behavior of the numerical solution.
\begin{quote}
\begin{itemize}
\item {} 
Movie of velocity profile (online available)

\end{itemize}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{VelProfile_Theta0.5_dt0001}.gif}
\end{figure}
\end{quote}
\begin{itemize}
\item {} 
\(dt' = 100\)

\end{itemize}

As already mentioned above, since the given \(\theta\) condition gives the stable solution, the improperly big time-step give rise to the extremely long period to have convergence. The second movie below shows the abnormal behavior of velocity profile. This may have to be involved with the inaccurate time gradient due to the big time-step, thus it leads to the negative velocity instantaneously and fluctuation of velocity profile.
\begin{quote}
\begin{itemize}
\item {} 
Movie of velocity profile (online available)

\end{itemize}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{VelProfile_Theta0.5_dt100}.gif}
\end{figure}
\end{quote}


\subparagraph{3) \protect\(\theta\protect\) = 1 (Fully implicit)}
\label{\detokenize{cases/results:fully-implicit}}\begin{itemize}
\item {} 
\sphinxstylestrong{Convergence check with the various time step:}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Non-dimensional time step \(\Delta t'\)
&
Maximum iteration for convergence
\\
\hline
0.0001
&
16004
\\
\hline
0.001
&
1608
\\
\hline
0.01
&
168
\\
\hline
0.1
&
23
\\
\hline
1.0
&
7
\\
\hline
10.0
&
4
\\
\hline
100.0
&
3
\\
\hline
1000.0
&
2
\\
\hline
10000.0
&
2
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

All the tested cases above are stable and the convergence performance is enhanced as the time step increases. Contrary to the Crank-Nicolson scheme case (\(\theta\) = 0.5), the pattern of maximum iteration for convergence shows the linearity as a function of time step. Therefore, it can be concluded that the solver follows the theoretical stability behavior.
\begin{itemize}
\item {} 
\(dt' = 0.0001\)
\begin{itemize}
\item {} 
Movie of velocity profile (online available)

\end{itemize}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{VelProfile_Theta1.0_dt0001}.gif}
\end{figure}

\(dt' = 0.1\)
\begin{itemize}
\item {} 
Movie of velocity profile (online available)

\end{itemize}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{VelProfile_Theta1.0_dt_01}.gif}
\end{figure}

\end{itemize}


\paragraph{H) Write down an expression(s) for the truncation error (TE) of this finite difference scheme and describe the order of accuracy of the scheme for different values of \protect\(\theta\protect\). Note: You are not required to derive the TE expression.}
\label{\detokenize{cases/results:h-write-down-an-expression-s-for-the-truncation-error-te-of-this-finite-difference-scheme-and-describe-the-order-of-accuracy-of-the-scheme-for-different-values-of-note-you-are-not-required-to-derive-the-te-expression}}\begin{equation*}
\begin{split}\text{T.E.} = \left [ \left ( \theta - \frac{1}{2} \right ) \Delta t + \frac{\Delta x^{2}}{12} \right ]u_{xxxx} + \left [ \left ( \theta^{2} - \theta + \frac{1}{3} \right )\Delta t^2 + \frac{1}{3} \left ( \theta - \frac{1}{2} \right )\Delta t \Delta x^2 + \frac{1}{360} \Delta x^{4} \right ] u_{xxxxxx} + \cdot \cdot \cdot\end{split}
\end{equation*}
According to the above equation, this combined method of explicit and implicit schemes has order of accuracy in time and space as a function of \(\theta\).
\begin{enumerate}
\item {} 
\(\theta\) = 1/2 (Crank-Nicolson scheme): \(\text{T.E.} = O\left [ (\Delta t)^{2}, (\Delta x)^{2} \right ]\)

\item {} 
Simple explicit (\(\theta\) = 0) and implicit (\(\theta\) = 1): \(\text{T.E.} = O\left [ \Delta t, (\Delta x)^{2} \right ]\)

\item {} 
Special case (\(\theta = \frac{1}{2} - \frac{(\Delta x)^{2}}{12\Delta t}\)): \(\text{T.E.} = O \left [ (\Delta t)^{2}, (\Delta x)^{4} \right ]\)

\end{enumerate}


\paragraph{I) Investigate the spatial order of accuracy of the code for \protect\(\theta\protect\) = 1. Do this by using a small value of \protect\(\Delta t'\protect\) = 0.000625 and running multiple cases of the code with different values of \protect\(\Delta y'\protect\) (i.e. 0.1, 0.05, 0.025, 0.0125). Make a table and log-log plot of the peak RMS error (relative to the time-dependent exact solution) as a function of \protect\(\Delta y'\protect\). Based on these results, discuss whether or not your solver follows the theoretical order of spatial accuracy given by the TE expression for the scheme. Also, explain why it is important to use a small \protect\(\Delta t'\protect\) when we investigate the spatial accuracy of this scheme.}
\label{\detokenize{cases/results:i-investigate-the-spatial-order-of-accuracy-of-the-code-for-1-do-this-by-using-a-small-value-of-0-000625-and-running-multiple-cases-of-the-code-with-different-values-of-i-e-0-1-0-05-0-025-0-0125-make-a-table-and-log-log-plot-of-the-peak-rms-error-relative-to-the-time-dependent-exact-solution-as-a-function-of-based-on-these-results-discuss-whether-or-not-your-solver-follows-the-theoretical-order-of-spatial-accuracy-given-by-the-te-expression-for-the-scheme-also-explain-why-it-is-important-to-use-a-small-when-we-investigate-the-spatial-accuracy-of-this-scheme}}\begin{itemize}
\item {} 
Comparison of Peak RMS error as a function of spatial steps

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline

dy
&
jmax
&
Max RMS error (\(\Delta t\) = 0.000625)
&
Max RMS error (\(\Delta t\) = 0.0001)
\\
\hline
0.1
&
11
&
0.309370E-02
&
0.239121E-02
\\
\hline
0.05
&
21
&
0.136823E-02
&
0.680258E-03
\\
\hline
0.025
&
41
&
0.945456E-03
&
0.265312E-03
\\
\hline
0.0125
&
81
&
0.838836E-03
&
0.162750E-03
\\
\hline
0.00625
&
161
&
0.811120E-03
&
0.137099E-03
\\
\hline
0.003125
&
321
&
0.803589E-03
&
0.130609E-03
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\(\Delta t\) = 0.000625
&
\(\Delta t\) = 0.0001
\\
\hline
\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MaxRMSlog_dt_000625}.png}
&
\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MaxRMSlog_dt_0001}.png}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

From the expression of the T.E. theoretical we see that for \(\theta\) = 1, the truncation error is 1st order in time and 2nd order in space. The maximum RMS error for every test cases shows the quantitatively quadratic pattern as a function of spatial step size. Moreover, the smaller time step (here, \(\Delta t'\) = 0.0001) makes this pattern more distinctive compared to the bigger time step. This is because the smaller time step can reduce the truncation error in time derivative and thus the RMS error is then significantly made by the spatial derivative terms.


\paragraph{J) Investigate the temporal order of accuracy of the code for \protect\(\theta\protect\) = 1 and \protect\(\theta\protect\) = 1/2. Do this by using jmax = 51 and various \protect\(\Delta t'\protect\) (i.e. 0.02, 0.01, 0.005, 0.0025, 0.00125, 0.000625). Make tables and a log-log plots of the peak RMS error (relative to the time-dependent exact solution) as a function \protect\(\Delta t'\protect\) for \protect\(\theta\protect\) = 1 and \protect\(\theta\protect\) = 1/2. Based on these results, discuss whether or not your solver follows the theoretical order of temporal accuracy given by the TE expression for the scheme.}
\label{\detokenize{cases/results:j-investigate-the-temporal-order-of-accuracy-of-the-code-for-1-and-1-2-do-this-by-using-jmax-51-and-various-i-e-0-02-0-01-0-005-0-0025-0-00125-0-000625-make-tables-and-a-log-log-plots-of-the-peak-rms-error-relative-to-the-time-dependent-exact-solution-as-a-function-for-1-and-1-2-based-on-these-results-discuss-whether-or-not-your-solver-follows-the-theoretical-order-of-temporal-accuracy-given-by-the-te-expression-for-the-scheme}}\begin{itemize}
\item {} 
Comparison of Peak RMS error as a function of temporal steps

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

dt
&
Max RMS error (\(\theta\) = 0.5)
&
Max RMS error (\(\theta\) = 1.0)
\\
\hline
0.02
&
0.769763E-03
&
0.240539E-01
\\
\hline
0.01
&
0.126926E-03
&
0.125364E-01
\\
\hline
0.005
&
8.561830E-05
&
0.643657E-02
\\
\hline
0.0025
&
8.312029E-05
&
0.329439E-02
\\
\hline
0.00125
&
7.312270E-05
&
0.169853E-02
\\
\hline
0.000625
&
3.314359E-05
&
0.894558E-03
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\(\theta\) = 0.5
&
\(\theta\) = 1.0
\\
\hline
\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MaxRMSlog_jmax_51}.png}
&
\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MaxRMSlogTheta1_jmax_51}.png}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The tested results presented above show the accuracy of numerical solution as a function of time step. The previous discussion on the truncation error tells that the fully implicit scheme (\(\theta\) = 1) follows the 1st order in time and the Crank-Nicolson scheme (\(\theta\) = 1/2) follows the 2nd order in time.



\renewcommand{\indexname}{Index}
\printindex
\end{document}